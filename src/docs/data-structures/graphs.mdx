---
title: Graph Data Structure Info
description: Learn about the graph data structure - computer science.
# image: /someImage.jpg     # used for og:image meta
---

## The Basics

A graph is a collection of nodes and the connection between those nodes.
There is no specific pattern between nodes that is required because graphs are non-linear data structures.

---

###

---

## Termonology

**Vertex**: A node in a graph.

**Edge**: The connection between two nodes in a graph.

**D Algorithm**:

---

###

---

## Types & Use Cases

Graphs are used all over the place in computer programming and beyond! Some typical places you will see them include, but is not limited to:

- Social Networks
- Location / Mapping
- Routing Algos
- Visual Hierarchy
- File System Optimizations
- Databases

**Weighted vs. Unweighted**: A weighted graph's edges have value(s) associated with them while an unweighted has none.

**Directed vs. Undirected**: A directed graph has directions assigned between vertices while the undirected graph has data flow both directions between vertices.

---

###

---

## Undirected Graph Implementation

```js title=scripts/undirected-adjacency-list-graph lineNumbers=true
//  Undirected Class Declaration
class UndirectedGraph {
  constructor() {
    this.adjList = {};
  }

  // METHOD to add a vertex
  addVertex(vtx) {
    if (!this.adjList[vtx]) this.adjList[vtx] = [];
  }

  // METHOD to add an edge
  addEdge(v1, v2) {
    if (this.adjList[v1] && this.adjList[v2]) {
      this.adjList[v1].push(v2);
      this.adjList[v2].push(v1);
    }
  }

  // METHOD to remove an edge
  removeEdge(v1, v2) {
    if (this.adjList[v1] && this.adjList[v2]) {
      this.adjList[v1] = this.adjList[v1].filter((v) => v !== v2);
      this.adjList[v2] = this.adjList[v2].filter((v) => v !== v1);
    }
  }

  // METHOD to remove a vertex
  removeVertex(vtx) {
    if (!this.adjList[vtx]) return null;

    for (let adj of this.adjList[vtx]) {
      removeEdge(vtx, adj);
    }

    delete this.adjList[vtx];
  }

  // METHOD to depth-first-search the graph recursively
  DFSRecursive(start) {
    const result = [];
    const visited = {};
    const adjList = this.adjList;

    // HELPER func to call recursively using outside vars
    (function dfs(vtx) {
      if (!vtx) return null;

      visited[vtx] = true;
      result.push(vtx);

      // Check if we have already been to neighbor and continue
      adjList[vtx].forEach((neighbor) => {
        if (!visited[neighbor]) {
          return dfs(neighbor);
        }
      });
    })(start);

    return result;
  }

  // METHOD to depth-first-search the graph iteratively
  DFSIterative(start) {
    const stack = [start];
    const result = [];
    const visited = {};
    visited[start] = true;

    // Keep checking if visited while the stack has nodes
    let curr;
    while (stack.length) {
      curr = stack.pop();
      result.push(curr);

      this.adjList[curr].forEach((neighbor) => {
        if (!visited[neighbor]) {
          visited[neighbor] = true;
          stack.push(neighbor);
        }
      });
    }
    return result;
  }

  // METHOD to breadth-first-search the graph recursively
  BFSRecursive(start) {}

  // METHOD to breadth-first-search the graph iteratively
  BFSIterative(start) {}
}

// Class Instantiation
const g = new UndirectedGraph();
```

---

## D Algo Implementation

```js title=scripts/type2 lineNumbers=true highlight={1,6}
// TSKGraph Class Declaration
class TSKGraph {
  constructor() {}
}

// Class Instantiation
```

---

---

## Big O Analysis

**Access**: O()

**Insertion**: O()

**Deletion**: O()

**Searching**: O()

---

###

---

<!-- #### Advantages

- 

#### Drawbacks

- 

---

###

--- -->

<!-- ## Advanced Graph Questions -->
