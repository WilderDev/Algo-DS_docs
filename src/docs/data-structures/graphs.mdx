---
title: Graph Data Structure Info
description: Learn about the graph data structure - computer science.
# image: /someImage.jpg     # used for og:image meta
---

## The Basics

A graph is a collection of nodes and the connection between those nodes.
There is no specific pattern between nodes that is required because graphs are non-linear data structures.

---

###

---

## Termonology

**Vertex**: A node in a graph.

**Edge**: The connection between two nodes in a graph.

**Height**: The number of edges or jumps from the starting node to another node.

**Dijkstra's Algorithm**: An algorithm that finds the shortest path between nodes in a graph.

---

###

---

## Types & Use Cases

Graphs are used all over the place in computer programming and beyond! Some typical places you will see them include, but is not limited to:

- Social Networks
- Location / Mapping
- Routing Algos
- Visual Hierarchy
- File System Optimizations
- Databases

**Weighted vs. Unweighted**: A weighted graph's edges have value(s) associated with them while an unweighted has none.

**Directed vs. Undirected**: A directed graph has directions assigned between vertices while the undirected graph has data flow both directions between vertices.

---

###

---

## Undirected Graph Implementation

```js title=scripts/undirected-adjacency-list-graph lineNumbers=true
//  Undirected Graph Class Declaration
class UndirectedGraph {
  constructor() {
    this.adjList = {};
  }

  // METHOD to add a vertex
  addVertex(vtx) {
    if (!this.adjList[vtx]) this.adjList[vtx] = [];
  }

  // METHOD to add an edge
  addEdge(v1, v2) {
    if (this.adjList[v1] && this.adjList[v2]) {
      this.adjList[v1].push(v2);
      this.adjList[v2].push(v1);
    }
  }

  // METHOD to remove an edge
  removeEdge(v1, v2) {
    if (this.adjList[v1] && this.adjList[v2]) {
      this.adjList[v1] = this.adjList[v1].filter((v) => v !== v2);
      this.adjList[v2] = this.adjList[v2].filter((v) => v !== v1);
    }
  }

  // METHOD to remove a vertex
  removeVertex(vtx) {
    if (!this.adjList[vtx]) return null;

    for (let adj of this.adjList[vtx]) {
      removeEdge(vtx, adj);
    }

    delete this.adjList[vtx];
  }

  // METHOD to depth-first-search the graph recursively
  DFSRecursive(start) {
    const result = [];
    const visited = {};
    const adjList = this.adjList;

    // HELPER func to call recursively using outside vars
    (function dfs(vtx) {
      if (!vtx) return null;

      visited[vtx] = true;
      result.push(vtx);

      // Check if we have already been to neighbor and continue
      adjList[vtx].forEach((neighbor) => {
        if (!visited[neighbor]) {
          return dfs(neighbor);
        }
      });
    })(start);

    return result;
  }

  // METHOD to depth-first-search the graph iteratively
  DFSIterative(start) {
    const stack = [start];
    const result = [];
    const visited = {};
    visited[start] = true;

    // Keep checking if visited while the stack has nodes
    let curr;
    while (stack.length) {
      curr = stack.pop();
      result.push(curr);

      this.adjList[curr].forEach((neighbor) => {
        if (!visited[neighbor]) {
          visited[neighbor] = true;
          stack.push(neighbor);
        }
      });
    }
    return result;
  }

  // METHOD to breadth-first-search the graph iteratively
  BFSIterative(start) {
    const queue = [start];
    const result = [];
    const visited = {};
    visited[start] = true;

    let curr;
    while (queue.length) {
      curr = queue.shift();
      result.push(curr);

      this.adjList[curr].forEach((neighbor) => {
        if (!visited[neighbor]) {
          visited[neighbor] = true;
          queue.push(neighbor);
        }
      });
    }
    return result;
  }
}

// Class Instantiation
const g = new UndirectedGraph();
```

---

## Dijkstra's Algorithm Implementation

```js title=scripts/dijkstra's-algorithm lineNumbers=true highlight={1,6}
// Dijkstra's Algo Class Declaration
class DijkstraAlgo {
  constructor() {}
}

// Class Instantiation
```

---

---

## Advantages & Drawbacks

There are two ways to store a graph in code:

**Adjacency Matrix**
Good for:

- Adding an Edge
- Removing an Edge
- Query a Graph
- If you don't have a lot of vertices
- Faster for specific lookup

**Adjacency List**
Good for:

-Adding an Edge

- Adding a Vertex
- Removing a Vertex
- Storage
- Easy to loop over edges
- Most real world data has sparse edges and larger graphs

---

###

--- -->

<!-- ## Advanced Graph Questions -->
