---
title: Stacks & Queues Data Structure Info
description: Learn about the stack and queue data structures - computer science.
# image: /someImage.jpg     # used for og:image meta
---

## The Basics

Stacks and queues are two data structures that perform similar operations.

The **stack** has two methods, `push` and `pop` to add/remove the most recent element from a collection respectively. It follows the **LIFO** Principal - The Last node to be added is the First node to be taken out. <br />
Real world example: _a stack of books/dishes._ <br />
Computer world examples: _Javascript Call-Stack._

The **queue** also has two methods `enqueue` and `dequeue`. These methods add/remove elemenets following the **FIFO** Princicpal - The First node added is the First one to be taken out. <br />
Real world example: _waiting in line._ <br />
Computer world example: _CPU Scheduling_

---

###

---

## Stack Implementation

```js title=scripts/stack lineNumbers=true highlight={1,9,26,39}
//  Stack Class Declaration
class Stack {
  constructor() {
    this.top = null;
    this.bot = null;
    this.size = 0;
  }

  // Add a node to the top of the stack
  push(val) {
    const newNode = new Node(val);

    if (this.size === 0) {
      this.top = newNode;
      this.bot = newNode;
    } else {
      const oldTop = this.top;
      this.top = newNode;
      newNode.next = oldTop;
    }

    this.size++;
    return this;
  }

  // remove the node from the top of the stack
  pop() {
    if (this.size === 0) return null;
    if (this.top === this.bot) this.bot = null;

    const oldTop = this.top;
    this.top = this.top.next;

    this.size--;
    return oldTop.val;
  }
}

// Class Instantiation
const myStack = new Stack();

myStack.push("First On The Stack");
myStack.push("Second Push");
myStack.push("Third On Stack For Tests");
```

---

## Queue Implementation

```js title=scripts/queue lineNumbers=true highlight={1,9,25,38}
// Queue Class Declaration
class Queue {
  constructor() {
    this.front = null;
    this.back = null;
    this.size = 0;
  }

  // add a node to the back of the queue
  enqueue(val) {
    const newNode = new Node(val);

    if (this.size === 0) {
      this.front = newNode;
      this.back = newNode;
    } else {
      this.back.next = newNode;
      this.back = newNode;
    }

    this.size++;
    return this;
  }

  // remove the first node in the queue
  dequeue() {
    if (this.size === 0) return null;
    if (this.front === this.back) this.back = null;

    const oldFront = this.front;
    this.front = this.front.next;

    this.size--;
    return oldFront.val;
  }
}

// Class Instantiation
const myQueue = new Queue();

myQueue.enqueue("First In Line");
myQueue.enqueue("Second Enqueue");
myQueue.enqueue("Third In Line. Got here late.");
```

---

---

## Big O Analysis

#### Stacks

**Access**: O(n)

**Insertion**: O(1)

**Deletion**: O(1)

**Searching**: O(n)

---

#### Queues

**Access**: O(n)

**Insertion**: O(1)

**Deletion**: O(1)

**Searching**: O(n)

---

###

---

<!-- #### Advantages

- 

#### Drawbacks

- 

---

###

--- -->

<!-- ## Advanced Stack & Queue Questions -->
